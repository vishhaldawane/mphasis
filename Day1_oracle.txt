





	Oracle SQL / PLSQL



1.	1
2.			6
3.	1 
4.	2
6. 			6
5.	1
7.	1
9.			6
10. 	2
11.	1
12.	1
8.	1
13.	0
14.	0
15.			5
16.	1
17.	1
18.	3
19.	1
20.	0
21.			5
23.	0
25.	1
26.	1
27.			5
28.	4
29.	3
24.  			6
30.	1
31.	1
32.	1
33.	3
35.	0
36.			6
37. 	4
38.	1
39.  	2
40.	1
41.				8
42. 	0
43.	0
44.	1
34.	1
45.	0	






		DataBase Management 	System -DBMS
		|	 create/update    |
		|	view/delete    automate
		|
	---------------------------------------------
	|	|	|	   |		|
   integral  floating  character String		date

	how do you store your exam data


	you make a time table

	number  date		time	varchar		varchar
================================================================
columns->Day	Date		Time	Subject		Venue
================================================================
row->	 1	19-Apr-21	10:30	Maths		School1
----------------------------------------------------------------
row->	 2	20-Apr-21	11:30	Physics		School2
----------------------------------------------------------------
row->	 3	21-Apr-21	14:30	Java		School1
----------------------------------------------------------------
row->	 4	22-Apr-21	09:30	English		School1
----------------------------------------------------------------
row->	 5	23-Apr-21	10:30	Geometry	School1
----------------------------------------------------------------
row->	 6	24-Apr-21	12:30	Biology		School2
----------------------------------------------------------------

there can be a table to hold my personal information
there can be a table to hold marks of each topic



	SQL


	"Structured" Query Language



	DQL - data query language
		select <-- find rows

	DDL - data definition language
		create/alter/truncate/drop <-- table structure

	DML - data manipulation language
		insert/update/delete <--rows

	TCL - transaction control langauage
		commit/rollback <-- save or discard data rows

	DCL - data control language
		grant/revoke <-- permissions to create/deny data



		DQL

	select  * | columnlist   from  table 
                |
	  all columns
		



 EMPNO ENAME      JOB                 MGR  HIREDATE         SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7839 KING       PRESIDENT            17-NOV-81       5000                    10
      7934 MILLER     CLERK           7782 23-JAN-82       1300                    10
      7782 CLARK      MANAGER         7839 09-JUN-81       2450                    10


      7698 BLAKE      MANAGER         7839 01-MAY-81       2850                    30
      7654 MARTIN     SALESMAN        7698 28-SEP-81       1250       1400         30
      7499 ALLEN      SALESMAN        7698 20-FEB-81       1600        300         30
      7844 TURNER     SALESMAN        7698 08-SEP-81       1500          0         30
      7900 JAMES      CLERK           7698 03-DEC-81        950                    30
      7521 WARD       SALESMAN        7698 22-FEB-81       1250        500         30

      7566 JONES      MANAGER         7839 02-APR-81       2975                    20
      7902 FORD       ANALYST         7566 03-DEC-81       3000                    20
      7369 SMITH      CLERK           7902 17-DEC-80        800                    20
      7788 SCOTT      ANALYST         7566 09-DEC-82       3000                    20
      7876 ADAMS      CLERK           7788 12-JAN-83       1100                    20
  


	EMP->				KING       
	EMP->				|7839 PRESIDENT
			-----------------------------------
	DEPT->		|10 ACCOUNTING	|20 RESEARCH	| 30 SALES
	DEPT->		|NEW YORK	|DALLAS		| CHICAGO
			|		|		|
	EMP->		CLARK		JONES		BLAKE		
	EMP->		|7782 MANAGER	|7566 MANAGER	| 7698 MANAGER
			|		|		|
		--------------	   --------------	---------------------------------
EMP->		|10		   |20		|20	|30	|30	|30	|30	|30
		|		   |		|	MARTIN ALLEN  TURNER   WARD	JAMES	
		|		   |		|	7654    7499    7844    7521	7900
EMP->	   MILLER		FORD		SCOTT   <---------SALESMAN-------->	CLERK
           |                    |               |
EMP->	   |10 CLERK		|7902 ANALYST	|7788 ANALYST
				|		|
EMP->				|20		|20
EMP->				SMITH		ADAMS	
				7369 CLERK	7876 CLERK




		MARTIN 7654 - GOT ONE CUSTOMER - 
		|			|
	   SALESMAN		-> 102 VOLLYRITE - THIS CUSTOMER MUST HAVE SOME ORDERS
					|
			







 KING HAS GOT IS BUSINESS OF SPORTS ACTIVITIES PRODUCTS


	KING IS SELLING SUCH SPORT PRODUCTS
	AND TO SELL THEM HE HAS APPOINTED SALESMEN


	oracle data is case sensitive

	query is not case sensitive







		3-TIER ARCHITECTURE




						empno,ename,job,salary
 1				data logic		|
				| ORACLE -  TABLES - EMP TABLE
		-----------------------------
			|
 2			business logic
			| JAVA	- CLASSES - Employee, 
			|		 EmpController <-- spring and hibernate
	---------------------------------
	|
 3	presentation logic
	|
	BROWSER - UI SCREEN - ANGULAR
				|
				EmpComponent
				|
			these four columns -> empno,ename,job,salary




	conversion functions




 SELECT * FROM DEPT WHERE DEPTNO=30;
 SELECT   EMPNO,ENAME,JOB,DEPTNO FROM EMP WHERE EMPNO=7654;
 SELECT   CUSTID,NAME,REPID FROM CUSTOMER WHERE CUSTID=102;
 SELECT * FROM ORD WHERE CUSTID=102;
 SELECT * FROM ITEM WHERE ORDID=614;
 SELECT * FROM PRODUCT WHERE PRODID IN (100860,100870,100871);





	Nested queries


	query within a query


		Query1 ... ( Query2 .... ( Query 3 ....) ... )  ... 
					 <------------->
					   inner most
			   <--------------------------------->
					outer one
		<-------------------------------------------------->
				outer most






	 SELECT CUSTID,NAME FROM CUSTOMER 

	 WHERE REPID = 

		(select EMPNO from emp 

			where deptno = 

			( select deptno from dept where LOC='CHICAGO' ) 

		and job='SALESMAN' AND ENAME='MARTIN');

	

	SELECT * FROM ITEM 
	WHERE ORDID IN 
		(SELECT ORDID FROM ORD 
		WHERE CUSTID = 
			(SELECT CUSTID FROM CUSTOMER 
			WHERE REPID = 
				(select EMPNO from emp 
				where deptno = 
					( select deptno from dept 
					where LOC='CHICAGO' ) 
					and job='SALESMAN' AND ENAME='MARTIN') 
		AND ORDID=614)
		);




	WRITE A QUERY TO IDENTIFY "CUSTOMER NAME" WHO HAS ORDERED "ACE TENNIS RACKET I"

		SELECT NAME,CITY,TOTAL FROM CUSTOMER 
		WHERE CUSTID IN 
			(SELECT CUSTID FROM ORD 
			WHERE ORDID IN 
				(SELECT ORDID FROM ITEM 
				WHERE PRODID = 
					(SELECT PRODID FROM PRODUCT 
						WHERE DESCRIP='ACE TENNIS RACKET I')));

	SHOW CUSTOMER WHO HAS ORDERED TOTAL MORE THAN 20,000

		SELECT CUSTID,NAME FROM CUSTOMER 
		WHERE CUSTID IN 
			(SELECT CUSTID FROM ORD 
				WHERE TOTAL > 20000);



	SHOW PRODUCTS ORDERED/SHIPPED ON 30-JUL-86

		SELECT * FROM PRODUCT 
		WHERE PRODID IN 
			(SELECT PRODID FROM ITEM 
			WHERE ORDID IN 
				( SELECT ORDID FROM ORD 
					WHERE SHIPDATE = '30-JUL-86'));



	SHOW PRODUCTS WHERE QUANTITY IS MORE THAN 400
		SELECT * FROM PRODUCT 
		WHERE PRODID IN 
			(SELECT PRODID FROM ITEM 
			WHERE QTY>400);



	SHOW CUSTOMER WHO HAS COMMISION PLAN IS 'A'

		SELECT NAME FROM CUSTOMER 
		WHERE CUSTID IN 
			(SELECT CUSTID FROM ORD 
			WHERE COMMPLAN='A');


	SHOW ORDERS WHERE CUSTOMERS CREDITLIMIT IS MORE THAN 8000

		SELECT * FROM ORD 
		WHERE CUSTID IN 
			(SELECT CUSTID FROM CUSTOMER 
			WHERE CREDITLIMIT>8000);

	

	SHOW THE HIGHEST COST ORDERED FROM ORD TABLE



GROUP BY
---------------


	SELECT DEPTNO,SUM(SAL) FROM EMP GROUP BY DEPTNO;
		|				  |
		---->--MUST BE MENTIONED IN - >->-+

	COLUMN MENTIONED IN SELECT QUERY MUST BE MENTIONED IN THE GROUP BY EXPRESSION
	BUT NOT OTHER WAY ROUND





	SELECT DEPTNO,JOB,SUM(SAL),COUNT(JOB) FROM EMP 

		WHERE JOB IN ('SALESMAN','CLERK') 

			GROUP BY DEPTNO,JOB 

				HAVING COUNT(JOB) > 2;



	OLAP FEATURE


		ORACLES ONLINE ANALYTICAL PROCESSING





	JOIN

		IS USED TO COMBINE THE COLUMNS OF MORE THAN 1 TABLE


	
1. CARTESION PRODUCT

	SELECT * FROM EMP,DEPT;	

	SELECT * FROM EMP,DEPT,CUSTOMER,ORD

		EMP X DEPT X CUSTOMER X ORD


2. EQUI JOIN

	SELECT ENAME || ' WORKING AS '||JOB || ' AT ' || LOC || ' IN ' || DNAME FROM DEPT,EMP
        WHERE DEPT.DEPTNO = EMP.DEPTNO;
			|	|
			---------

	SELECT DNAME,ENAME,NAME FROM DEPT,EMP,CUSTOMER
  	  WHERE DEPT.DEPTNO = EMP.DEPTNO AND
  	  EMP.EMPNO = CUSTOMER.REPID;

	SELECT DNAME,ENAME,NAME,TOTAL FROM DEPT,EMP,CUSTOMER,ORD
  	  WHERE DEPT.DEPTNO = EMP.DEPTNO AND
  	  EMP.EMPNO = CUSTOMER.REPID AND
	  CUSTOMER.CUSTID = ORD.CUSTID

	
	IN EQUI JOIN 
		THE NUMBER OF TABLES - 1 = TOTAL EQUI JOIN CONDITIONS



3. NON-EQUI
		       <-----EMP---------> <-SALGRADE->
 		SELECT EMPNO,ENAME,JOB,SAL,   GRADE      FROM EMP,SALGRADE
		WHERE SAL BETWEEN LOSAL AND HISAL;
			|	    |        |
			|	    | RANGE  |
			+-----------+--------+

	
4. OUTER JOIN		- TO SHOW UNMATCHED ROWS

	RIGHT OUTER
	LEFT OUTER
	FULL OUTER




 CREATE TABLE SUBJECT
    (
      SUBJECT_ID NUMBER,
      SUBJECT_NAME VARCHAR2(20),
      AUTH_ID NUMBER
    );

INSERT INTO SUBJECT VALUES (10,'JAVA',111);
INSERT INTO SUBJECT VALUES (20,'ORACLE',222);
INSERT INTO SUBJECT VALUES (30,'UNIX',NULL);


CREATE TABLE AUTHOR
    (
       AUTHOR_ID NUMBER,
       AUTHOR_NAME VARCHAR2(20),
       SUB_ID NUMBER
    );

INSERT INTO AUTHOR VALUES (111,'JAMES GOSLING',10);
INSERT INTO AUTHOR VALUES (222,'SCOTT MAYER',20);
INSERT INTO AUTHOR VALUES (333,'RICHARD STALLMAN',NULL);


SELECT SUBJECT_ID,SUBJECT_NAME, AUTHOR_ID,AUTHOR_NAME FROM SUBJECT,AUTHOR
    WHERE SUBJECT_ID (+)= SUB_ID;

SELECT SUBJECT_ID,SUBJECT_NAME, AUTHOR_ID,AUTHOR_NAME FROM SUBJECT,AUTHOR
    WHERE SUBJECT_ID = SUB_ID(+);



	SELECT SUBJECT_ID,SUBJECT_NAME, AUTHOR_ID,AUTHOR_NAME 
	FROM SUBJECT
		RIGHT OUTER JOIN  AUTHOR
		ON SUBJECT_ID = SUB_ID;

	SELECT SUBJECT_ID,SUBJECT_NAME, AUTHOR_ID,AUTHOR_NAME 
	FROM SUBJECT
		LEFT OUTER JOIN  AUTHOR
		ON SUBJECT_ID = SUB_ID;

	SELECT SUBJECT_ID,SUBJECT_NAME, AUTHOR_ID,AUTHOR_NAME 
	FROM SUBJECT
		FULL OUTER JOIN  AUTHOR
		ON SUBJECT_ID = SUB_ID;

	---------------------------------------------------
	SELECT SUBJECT_ID,SUBJECT_NAME, AUTHOR_ID,AUTHOR_NAME 
	FROM SUBJECT
		RIGHT OUTER JOIN  AUTHOR
		ON AUTHOR_ID = AUTH_ID


	SELECT SUBJECT_ID,SUBJECT_NAME, AUTHOR_ID,AUTHOR_NAME 
	FROM SUBJECT
		LEFT OUTER JOIN  AUTHOR
		ON AUTHOR_ID = AUTH_ID


	SELECT SUBJECT_ID,SUBJECT_NAME, AUTHOR_ID,AUTHOR_NAME 
	FROM SUBJECT
		FULL OUTER JOIN  AUTHOR
		ON AUTHOR_ID = AUTH_ID



5. SELF JOIN

		TABLE JOINING ITSELF



	SELECT 
		M.EMPNO,M.ENAME,M.JOB, 
		W.EMPNO,W.ENAME,W.JOB,W.MGR  

		FROM EMP M, EMP W

	        WHERE M.EMPNO = W.MGR;









=================================================



	KNOWLEDGE + VISION + ATTITUDE (LEARNING)

below code is hibernate framewok code

@Entity
@Table(name="emp")
Class Employee
{
	@Id
	@Column(name="EMPNO")
	private int employeeNumber;

	
	private String 	EMPNAME	;
	private String DESG;
	private double	SALARY;


	@ManyToOne
	private Dept d;
	
}








	DDL

		DATA DEFINITION LANGUAGE


		create table - make a table

		alter table - modify the table

		drop table - removes the table along with entire data

		truncate table - removes only the data - table structure remains



		number		- integral ( 40 digits )

		
		number(9,2)	- float
		number(12,5)	- float

		char		- for holding characters
		char(10)	- to hold 10 letters	- 'April' - still occupies 10 letters

		varchar2(10)	- to hold max 10 letters - 'April' - will occupy 5 letters
							    'May' - will occupy 3 letters


		date		- to hold date - 'dd-Mon-yy' ie  '10-Jan-21'


   DQL
	select
	nested query
	joins
	normalization

		
		create table employee
		(
		    empno number(4),
		    ename varchar2(20),
		    age   number(3),
		    email varchar2(20),
		    birthdate date,
		    salary number(12,2)
		);

	insert into employee values (1234,'Jack',20,'jack@gmail.com','10-Jan-2000',5000);
	insert into employee values (1235,'Jane',20,'jane@gmail.com','12-Feb-2000',6000);
	insert into employee values (1234,'Jobby',21,'jobby@gmail.com','11-Mar-1999',4500);
		    
		   	
	set linesize 120;

	select * from employee;


	we have to put some constraints/restrictions on the table's data

	
		1. integrity constraint

			primary key

				unique + not null


		2. unique constraint

				unique value ( can have null )

		3. not null constraint

				no null value allowed
				value is mandatroy

		4. check constraint

				validate data against a check condition

		5. referential integrity constraint

				value inserted against a primary key


		2021 -18 

		create table employee1
		(
		    empno number(4)	primary key,
		    ename varchar2(20)  not null,
		    age   number(3)     check (age>=18),
		    email varchar2(20)  unique,
		    birthdate date      check (birthdate<'1-Jan-2003'),
		    salary number(12,2) check (salary >= 5000)
		);

insert into employee1 values (1234,'Jane',21,'jane@gmail.com','10-Feb-2001',6500);
insert into employee1 values (1234,'Jane',21,'jane@gmail.com','10-Feb-2001',6500);
  - unique constraint (SYSTEM.SYS_C008835) violated - when duplicate emp number entered - PK

insert into employee1 values (1234,'Jane',21,'jane@gmail.com','10-Feb-2001',4500)
  - check constraint  (SYSTEM.SYS_C008834) violated - when salary was 4500

insert into employee1 values (1235,'Jane',11,'jane@gmail.com','10-Feb-2001',6500);
  - check constraint  (SYSTEM.SYS_C008832) violated - when age was as 11

insert into employee1 values (1235,null,21,'jane@gmail.com','10-Feb-2001',6500);
  - cannot insert NULL into ("SYSTEM"."EMPLOYEE1"."ENAME") - when name was null

insert into employee1 values (1235,'Jane',21,'jane@gmail.com','10-Feb-2022',6500);
  - check constraint  (SYSTEM.SYS_C008833) violated - birthdate as 10-Feb-2022

insert into employee1 values (1235,'Jane',21,'jack@gmail.com','10-Feb-2001',5500);
  - unique constraint (SYSTEM.SYS_C008836) violated
		create table dept1
		(
		   deptno number primary key,
                   dname  varchar2(20) not null,
		   loc    varchar2(20) check ( loc in ('NY','ND','DALLAS','CHICAGO'))
		);
 INSERT INTO DEPT1 VALUES (10,'DEVELOPMENT','NY');
 INSERT INTO DEPT1 VALUES (20,'TESTING','ND');
 INSERT INTO DEPT1 VALUES (30,'QMS','DALLAS');
 INSERT INTO DEPT1 VALUES (40,'DEPLOYMENT','CHICAGO');

		create table employee2
		(
		    empno number(4)	primary key,
		    ename varchar2(20)  not null,
		    age   number(3)     check (age>=18),
		    email varchar2(20)  unique,
		    birthdate date      check (birthdate<'1-Jan-2003'),
		    salary number(12,2) check (salary >= 5000),
		    DEPTNUM NUMBER REFERENCES DEPT1 ( DEPTNO )
		);
insert into employee2 values (1234,'Jane',21,'jane@gmail.com','10-Feb-2001',6500,10);
insert into employee2 values (1235,'Jack',21,'jack@gmail.com','11-Nov-2001',7500,15);
  - integrity constraint (SYSTEM.SYS_C008846) violated - parent key not found

		deptno 15 does not exist in dept1


	DATA DICTIONARY - META DATA - ORACLE GENERATED CONSTRAINT NAMES

    select constraint_name,constraint_type,search_condition
    from user_constraints where table_name='EMPLOYEE1';
						TABLE NUME MUST BE IN CAPITAL 

	ONCE U HAVE DONE PLS CHAT


		create table employee3
		(
		    empno number(4)     CONSTRAINT MY_EMP3_PK primary key,
		    ename varchar2(20)  CONSTRAINT MY_EMP3_ENM_NN not null,
		    age   number(3)     CONSTRAINT MY_EMP3_CHK_AGE    check (age>=18),
		    email varchar2(20)  CONSTRAINT MY_EMP3_CHK_EMAIL  unique,
		    birthdate date      CONSTRAINT MY_EMP3_CHK_BDATE  check (birthdate<'1-Jan-2003'),
		    salary number(12,2) CONSTRAINT MY_EMP3_CHK_SAL    check (salary >= 5000),
		    DEPTNUM NUMBER      CONSTRAINT MY_EMP3_CHK_DEPTNO REFERENCES DEPT1 ( DEPTNO )
		);

	insert into employee3 values (1234,'Jane',21,'jane@gmail.com','10-Feb-2001',6500,10);
	1 row created.
SQL> insert into employee3 values (1234,'Jane',21,'jane@gmail.com','10-Feb-2001',6500,10);
	ORA-00001: unique constraint (SYSTEM.MY_EMP3_PK) violated
SQL> insert into employee3 values (1235,NULL,21,'jane@gmail.com','10-Feb-2001',6500,10);
	ORA-01400: cannot insert NULL into ("SYSTEM"."EMPLOYEE3"."ENAME")
SQL> insert into employee3 values (1235,'Jack',11,'jane@gmail.com','10-Feb-2001',6500,10);
	ORA-02290: check constraint (SYSTEM.MY_EMP3_CHK_AGE) violated
SQL> insert into employee3 values (1235,'Jack',22,'jane@gmail.com','10-Feb-2001',6500,10);
	ORA-00001: unique constraint (SYSTEM.MY_EMP3_CHK_EMAIL) violated
SQL> insert into employee3 values (1235,'Jack',22,'jack@gmail.com','10-Feb-2022',6500,10);
	ORA-02290: check constraint (SYSTEM.MY_EMP3_CHK_BDATE) violated
SQL> insert into employee3 values (1235,'Jack',22,'jack@gmail.com','10-Feb-2002',1500,10);
	ORA-02290: check constraint (SYSTEM.MY_EMP3_CHK_SAL) violated
SQL> insert into employee3 values (1235,'Jack',22,'jack@gmail.com','10-Feb-2002',5500,18);
	ORA-02291: integrity constraint (SYSTEM.MY_EMP3_CHK_DEPTNO) violated - parent key not found



				Issue Contraints
					|
			----------------------------------------------
			|				|
		column level				table level

		create table employee3
		(
		    empno number(4)     CONSTRAINT MY_EMP3_PK primary key, <- column level
		    ename varchar2(20)  CONSTRAINT MY_EMP3_ENM_NN not null, <- column level
		    age   number(3)     CONSTRAINT MY_EMP3_CHK_AGE    check (age>=18), <- column level
		    email varchar2(20)  CONSTRAINT MY_EMP3_CHK_EMAIL  unique, <- column level
		    birthdate date      CONSTRAINT MY_EMP3_CHK_BDATE  check (birthdate<'1-Jan-2003'), <- column level
		    salary number(12,2) CONSTRAINT MY_EMP3_CHK_SAL    check (salary >= 5000), <- column level
		    DEPTNUM NUMBER      CONSTRAINT MY_EMP3_CHK_DEPTNO REFERENCES DEPT1 ( DEPTNO ) <- column level
		);



		create table employee4
		(
		    empno number(4),     
		    ename varchar2(20) CONSTRAINT MY_EMP4_ENM_NN not null,
		    age   number(3),   
		    email varchar2(20),
		    birthdate date, 
		    salary number(12,2),
		    comm number(12,2),
		    DEPTNUM NUMBER,
		    CONSTRAINT MY_EMP4_PK primary key(empno), 
		    CONSTRAINT MY_EMP4_CHK_AGE    check (age>=18), 
		    CONSTRAINT MY_EMP4_CHK_EMAIL  unique(email), 
		    CONSTRAINT MY_EMP4_CHK_BDATE  check (birthdate<'1-Jan-2003'), 
		    CONSTRAINT MY_EMP4_CHK_SAL    check (salary >= 5000), 
		    CONSTRAINT MY_EMP4_CHK_COMM   check (comm < salary ),
		    CONSTRAINT MY_EMP4_CHK_DEPTNO FOREIGN KEY (DEPTNUM) REFERENCES DEPT1 ( DEPTNO ) 
		);

		NOT NULL CONSTRAINT CANNOT BE GIVEN AT TABLE LEVEL
		IT HAS TO BE ISSUED ALONG WITH THE COLUMN DEFINITION
	



	TCL


		Transaction control language


			- commit - to update the database file on the harddrive

			- rollback - undo the recent changes DONE AFTER LAST COMMIT


		SQL> TABLE HAS 5 RECORDS

		SQL> INSERTED ONE RECORD   ( NOW TABLE HAS 6 RECORDS)
		SQL> UPDATED ONE RECORD	  ( OUT OF 6 ONE RECORD IS MODIFIED )
		SQL> DELETED TWO RECORDS   ( OUT OF 6 TWO ARE DELETED, HENCE 4 ROWS REMAIN )

		SQL> COMMIT;  ( THIS WILL COMFIRM ALL THE ABOVE CHANGES )

		SQL> INSERTED 5 RECORDS ( NOW IT HAS TOTAL 9 RECORDS )
		SQL> DELETED 2 RECORD ( NOW IT HAS 7 RECORDS )

		SQL> ROLLBACK 

DML - DATA MANIPULATION

		UPDATE DEPT1   SET   DNAME='SALES', LOC='NY' WHERE DEPTNO=50;

		DELETE FROM DEPT1 WHERE DEPTNO=30;


		
	DCL

		DATA CONTROL LANGUAGE

	select name,open_mode  from v$pdbs;
	alter session set container=pdb1;
	alter pluggable database pdb1 open;




			USERNAME		PASSWORD
			     |			    |		    
SYSTEM	SQL>	CREATE USER JACKIE IDENTIFIED BY DIAMOND
SYSTEM	SQL>	GRANT ALL PRIVILEGES TO JACKIE


SYSTEM	SQL> CONNECT JACKIE/DIAMOND

JACKIE	SQL> CREATE TABLE EMP ( EMPNO NUMBER ); 
JACKIE	SQL>  INSERT INTO EMP VALUES (10);
	      INSERT INTO EMP VALUES (20);
              INSERT INTO EMP VALUES (30);

JACKIE	SQL>  SELECT * FROM EMP;

JACKIE  SQL> CONN /AS SYSDBA

SYSDBA  SQL> REVOKE ALL PRIVILEGES FROM JACKIE;

SYSDBA  SQL> CONNECT JACKIE/DIAMOND





	DCL - data control language

	SQL> conn /as sysdba
	SQL> alter session set "_ORACLE_SCRIPT"=true;

	SQL> create user jack3 identified by tiger3;
	SQL> grant all privileges to jack3;


	SQL> connect jack3/tiger3
jack3	SQL> create table emp ( empno number );
	SQL> insert ....
	
	SQL> connect /as sysdba
sysdba	SQL> revoke all privileges from jack3;

	SQL> connect jack3/tiger3

	
		

	set operators	
	-------------------

		union
		A	select rownum, empno,ename,job,sal,deptno from emp where rownum<=5
		<	union
		B	select rownum, empno,ename,job,sal,deptno from emp where rownum<=7;

		union all
		A	select rownum, empno,ename,job,sal,deptno from emp where rownum<=5
		+	union all
		B	select rownum, empno,ename,job,sal,deptno from emp where rownum<=7;

		intersect
			select rownum, empno,ename,job,sal,deptno from emp where rownum<=5
			intersect
			select rownum, empno,ename,job,sal,deptno from emp where rownum<=7;

		minus
			select rownum, empno,ename,job,sal,deptno from emp where rownum<=7
			minus
			select rownum, empno,ename,job,sal,deptno from emp where rownum<=5;

			


	PL- SQL


		Procedural Language - for SQL


		Sequential code
			- series of lines

		Selective code
			- if condition

		Iterative code
			- loop




		declare <-- optional

			 some variables are declared here

		begin
			pl sql block to run

		end;



		SQL> set serveroutput on



	Annonymous block <--- the block that does not have a name - nameless

		SQL> begin
			 dbms_output.put_line('Welcome to the world of PL SQL');
			 dbms_output.put_line('its more simple....');

		end; <-- semicolon here
		/    <-- to run it

		


   declare
        a number:=100;
        b varchar2(20):='New York';
        c char(1):='Y';
        d date:='10-Mar-2022';
        e number(9,2):=9000.12;
    begin
        dbms_output.put_line('value of a ' || a);
        dbms_output.put_line('value of b ' || b);
        dbms_output.put_line('value of c ' || c);
        dbms_output.put_line('value of d ' || d);
        dbms_output.put_line('value of e ' || e);
    end;
   /
	
	WE CANNOT WRITE SQL'S SELECT QUERY IN PL/SQL BLOCK
			
------------------------------------------------
        declare
                mydeptno number;
                mydeptName varchar2(9);
                mydeptLoc  varchar2(10);
        begin
                select DEPTNO,DNAME,LOC INTO MYDEPTNO,MYDEPTNAME,MYDEPTLOC from dept	
		WHERE DEPTNO=&NUM;

                dbms_output.put_line('dept number   : ' || mydeptno);
                dbms_output.put_line('dept name     : ' || mydeptname);
                dbms_output.put_line('dept location : ' || mydeptLoc);
        end;


------------------------------------------------

  	declare
                mydeptno   DEPT.DEPTNO%TYPE;
                mydeptName DEPT.DNAME%TYPE;
                mydeptLoc  DEPT.LOC%TYPE;
        begin
                select DEPTNO,DNAME,LOC INTO MYDEPTNO,MYDEPTNAME,MYDEPTLOC from dept	
		WHERE DEPTNO=&NUM;

                dbms_output.put_line('dept number   : ' || mydeptno);
                dbms_output.put_line('dept name     : ' || mydeptname);
                dbms_output.put_line('dept location : ' || mydeptLoc);
        end;

------------------------------------------------

	declare
                mydeptno   DEPT.DEPTNO%TYPE;
                mydeptName DEPT.DNAME%TYPE;
                mydeptLoc  DEPT.LOC%TYPE;
        begin
                select * INTO MYDEPTNO,MYDEPTNAME,MYDEPTLOC from dept	
		WHERE DEPTNO=&NUM;

                dbms_output.put_line('dept number   : ' || mydeptno);
                dbms_output.put_line('dept name     : ' || mydeptname);
                dbms_output.put_line('dept location : ' || mydeptLoc);
        end;
	
------------------------------------------------
		
	declare
		TYPE MYDEPT IS RECORD
		(
	                mydeptno   DEPT.DEPTNO%TYPE, -- %TYPE MEANS INDIVIDUAL COLUMN
        	        mydeptName DEPT.DNAME%TYPE,
                	mydeptLoc  DEPT.LOC%TYPE
		);
		
		D MYDEPT; -- HERE D IS THE VARIABLE OF DATA TYPE MYDEPT
		
        begin
                select * INTO D from dept WHERE DEPTNO=&NUM;

                dbms_output.put_line('dept number   : ' || D.mydeptno);
                dbms_output.put_line('dept name     : ' || D.mydeptname);
                dbms_output.put_line('dept location : ' || D.mydeptLoc);
        end;

----------------------------------------------------------

        declare
		   	
		D DEPT%ROWTYPE; -- %ROWTYPE MEANS CONSIDER ALL COLUMNS AND THEIR TYPES
		
        begin
                select * INTO D from dept WHERE DEPTNO=&NUM;

                dbms_output.put_line('dept number   : ' || D.DEPTNO);
                dbms_output.put_line('dept name     : ' || D.DNAME);
                dbms_output.put_line('dept location : ' || D.LOC);
        end;

----------------------------------------------------------------------

        declare
		TYPE MyDeptEmpCustomer IS RECORD
		(
        	        myDeptName DEPT.DNAME%TYPE,
        	        myEmpName  EMP.ENAME%TYPE,
        	        myCustName CUSTOMER.NAME%TYPE
		);
		
		dec MyDeptEmpCustomer ; -- HERE D IS THE VARIABLE OF composite type
		
        begin
                select dname,ename,name INTO dec from dept,emp,customer
		WHERE dept.deptno=emp.deptno and emp.empno=customer.repid
		and emp.empno=7654;

                dbms_output.put_line('DEPT NAME     : ' || dec.myDeptName);
                dbms_output.put_line('EMP  NAME     : ' || dec.myEMPNAME);
                dbms_output.put_line('CUSTOMER NAME : ' || DEC.myCustNAME);
        end;
-----------------------------------------------------------------------------


	declare
		age number;
	begin
		age:=&temp;
		dbms_output.put_line('age is : '||age);
		
		if (age>=18) 
		then
			dbms_output.put_line('You can VOTE');
		else
			dbms_output.put_line('You CANNOT VOTE');
		end if;
	end;

--------------------------------------------------------------------

	declare
		num number;
	begin
		num:=&temp;
		dbms_output.put_line('num is : '||num);
		
		if (num>10) 
		then
			dbms_output.put_line(num||' is higher than 10');
		else
			if(num<10)
			then
				dbms_output.put_line(num||' is lesser than 10');
			else
				dbms_output.put_line(num||' is equals to 10');
			end if;
		end if;
	end;

--------------------------------------------------------------------
	
	declare
		x number:=1;
	begin
		dbms_output.put_line('Begin');
		while (x<=10)
		loop
		  dbms_output.put_line('x : '||x);
		  x:=x+1;
		end loop;
		dbms_output.put_line('End');
	end;
	

	Assignment : make a table of 1 to 10 : hint : nested loop

	declare
		x number:=1;
		y number:=1;
	begin
		dbms_output.put_line('Begin');

		while (x<=10)
		loop
			y:=1;
			while(y<=10)
			loop
				dbms_output.put(' '||x*y);
				y:=y+1;
			end loop;
			dbms_output.put_line('');
			dbms_output.put_line('-------------------------------');
		  x:=x+1;
		end loop;
		dbms_output.put_line('End');
	end;
	
-----------------------------------------------------------------


	CURSOR
	----------


		CURSOR = IS A POINTER TO THE ACTIVE DATA SET


				CURSOR
				|
			------------------
			|		|
			IMPLICIT	EXPLICIT
			|		|
			SQL		USER DEFINED NAME


			CURSOR HAS ATTRIBUTES
					|
			----------------------------------
			|	|	|	|
		    ISOPEN   FOUND   NOTFOUND  ROWCOUNT

 DECLARE
       X NUMBER;
    BEGIN
       DBMS_OUTPUT.PUT_LINE('DELETE RECORDS PROGRAM');
       X:=&NUM;
       delete from emp where deptno=x;
       if (SQL%found) then
           DBMS_OUTPUT.PUT_LINE('Records deleted : '||sql%rowcount);
       else
          DBMS_OUTPUT.PUT_LINE('Records not found');
      end if;
   end;
   /


  DECLARE

       DNO NUMBER;
       SALPER NUMBER;

    BEGIN

       DBMS_OUTPUT.PUT_LINE('UPDATE RECORDS PROGRAM');

       DNO:=&DEPTNUMBER;
       SALPER:=&SALARYPERCENTAGE;

       UPDATE EMP SET SAL=SAL+SAL*SALPER where deptno=DNO;
       COMMIT; -- IF YOU WANT THE DATA TO BE CHANGED IN THE DBFILE

       if (SQL%found) then
           DBMS_OUTPUT.PUT_LINE('Records UPDATED : '||sql%rowcount);
       else
          DBMS_OUTPUT.PUT_LINE('Records not found');
       end if;

   end;
   /

-------------------------------------------------------

       DECLARE
         CURSOR MYDEPTCUR IS SELECT * FROM DEPT; -- declare cursor
         DEPTREC DEPT%ROWTYPE; 
       BEGIN
         DBMS_OUTPUT.PUT_LINE('BEGIN');
         DBMS_OUTPUT.PUT_LINE('OPENING CURSOR');
         OPEN MYDEPTCUR; -- now its pointing to the active data set

         FETCH MYDEPTCUR INTO DEPTREC; -- fetch first record
            WHILE(MYDEPTCUR%FOUND) -- test if it is found
            LOOP
                DBMS_OUTPUT.PUT_LINE('ROW    : '||MYDEPTCUR%ROWCOUNT);
                DBMS_OUTPUT.PUT_LINE('DEPTNO : '||DEPTREC.DEPTNO);
                DBMS_OUTPUT.PUT_LINE('DNAME  : '||DEPTREC.DNAME);
                DBMS_OUTPUT.PUT_LINE('LOC    : '||DEPTREC.LOC);
                DBMS_OUTPUT.PUT_LINE('--------------------------');
                FETCH MYDEPTCUR INTO DEPTREC; -- fetch successive records
            END LOOP;
         DBMS_OUTPUT.PUT_LINE('CLOSING CURSOR..');
	 CLOSE MYDEPTCUR; -- close the active data set
         DBMS_OUTPUT.PUT_LINE('CURSOR CLOSED....');
        DBMS_OUTPUT.PUT_LINE('END');
       END;

----------------------------------------------------------	

     DECLARE
         CURSOR MYEMPCUR IS SELECT * FROM EMP WHERE JOB='&VJOB'; -- declare cursor
         EMPREC EMP%ROWTYPE; 
       BEGIN
         DBMS_OUTPUT.PUT_LINE('BEGIN');
         DBMS_OUTPUT.PUT_LINE('OPENING CURSOR');
         OPEN MYEMPCUR; -- now its pointing to the active data set

         FETCH MYEMPCUR INTO EMPREC; -- fetch first record
            WHILE(MYEMPCUR%FOUND) -- test if it is found
            LOOP
                DBMS_OUTPUT.PUT_LINE('ROW    : '||MYEMPCUR%ROWCOUNT);
                DBMS_OUTPUT.PUT_LINE('EMPNO : '||EMPREC.EMPNO);
                DBMS_OUTPUT.PUT_LINE('ENAME : '||EMPREC.ENAME);
                DBMS_OUTPUT.PUT_LINE('JOB   : '||EMPREC.JOB);
                DBMS_OUTPUT.PUT_LINE('--------------------------');
                FETCH MYEMPCUR INTO EMPREC; -- fetch successive records
            END LOOP;
         DBMS_OUTPUT.PUT_LINE('CLOSING CURSOR..');
	 CLOSE MYEMPCUR; -- close the active data set
         DBMS_OUTPUT.PUT_LINE('CURSOR CLOSED....');
        DBMS_OUTPUT.PUT_LINE('END');
       END;

---------------------------------------------------------------------

DECLARE
         CURSOR MYDEPTCUR IS SELECT * FROM DEPT; -- declare cursor
         DEPTREC DEPT%ROWTYPE; 
       BEGIN
         DBMS_OUTPUT.PUT_LINE('BEGIN');
         DBMS_OUTPUT.PUT_LINE('OPENING CURSOR');
         OPEN MYDEPTCUR; -- now its pointing to the active data set

         FETCH MYDEPTCUR INTO DEPTREC; -- fetch first record
            WHILE(MYDEPTCUR%FOUND) -- test if it is found
            LOOP
                DBMS_OUTPUT.PUT_LINE('ROW    : '||MYDEPTCUR%ROWCOUNT);
                DBMS_OUTPUT.PUT_LINE('DEPTNO : '||DEPTREC.DEPTNO);
                DBMS_OUTPUT.PUT_LINE('DNAME  : '||DEPTREC.DNAME);
                DBMS_OUTPUT.PUT_LINE('LOC    : '||DEPTREC.LOC);
                DBMS_OUTPUT.PUT_LINE('--------------------------');
                FETCH MYDEPTCUR INTO DEPTREC; -- fetch successive records
            END LOOP;
         DBMS_OUTPUT.PUT_LINE('CLOSING CURSOR..');
	 CLOSE MYDEPTCUR; -- close the active data set
         DBMS_OUTPUT.PUT_LINE('CURSOR CLOSED....');

         DBMS_OUTPUT.PUT_LINE('FETCHING THE RECORDS...AGAIN....');

         OPEN MYDEPTCUR; --reopen the cursor 

	   FETCH MYDEPTCUR INTO DEPTREC; -- fetch first record
            WHILE(MYDEPTCUR%FOUND) -- test if it is found
            LOOP
                DBMS_OUTPUT.PUT_LINE('ROW    : '||MYDEPTCUR%ROWCOUNT);
                DBMS_OUTPUT.PUT_LINE('DEPTNO : '||DEPTREC.DEPTNO);
                DBMS_OUTPUT.PUT_LINE('DNAME  : '||DEPTREC.DNAME);
                DBMS_OUTPUT.PUT_LINE('LOC    : '||DEPTREC.LOC);
                DBMS_OUTPUT.PUT_LINE('--------------------------');
                FETCH MYDEPTCUR INTO DEPTREC; -- fetch successive records
            END LOOP;
        close mydeptcur;
        DBMS_OUTPUT.PUT_LINE('closed the cursor...');
        
        DBMS_OUTPUT.PUT_LINE('END');
       END;

--------------------------------------------------------------------




        begin
            for x in 1..10
            loop
                DBMS_OUTPUT.PUT_LINE('x '||x);
            end loop;
        end;

--------------------------------------------------------------------

        begin
	    for x in reverse 1..10
            loop
                DBMS_OUTPUT.PUT_LINE('x '||x);
            end loop;
        end;

------------------------------------------------------------------------
DECLARE
         CURSOR MY_DEPT_EMP_CUST_CUR IS SELECT dept.deptno,dname,loc, empno,ename,job,
                custid,name,city FROM DEPT,emp,customer where dept.deptno = emp.deptno 
                and emp.empno=customer.repid order by emp.empno; -- declare cursor
         decRec MY_DEPT_EMP_CUST_CUR%ROWTYPE; -- declare cursor type variable
       BEGIN
         DBMS_OUTPUT.PUT_LINE('BEGIN'); DBMS_OUTPUT.PUT_LINE('OPENING CURSOR');
         OPEN MY_DEPT_EMP_CUST_CUR; -- now its pointing to the active data set
         FETCH MY_DEPT_EMP_CUST_CUR INTO decRec; -- fetch first record
           WHILE(MY_DEPT_EMP_CUST_CUR%FOUND) -- test if it is found
            LOOP
                DBMS_OUTPUT.PUT_LINE('ROW      : '||MY_DEPT_EMP_CUST_CUR%ROWCOUNT);
                DBMS_OUTPUT.PUT_LINE('DEPTNO   : '||decRec.DEPTNO); DBMS_OUTPUT.PUT_LINE('DNAME    : '||decRec.DNAME);
                DBMS_OUTPUT.PUT_LINE('LOC      : '||decRec.LOC);
                DBMS_OUTPUT.PUT_LINE('---------------------------');
                DBMS_OUTPUT.PUT_LINE('EMPNO    : '||decRec.EMPNO); DBMS_OUTPUT.PUT_LINE('ENAME    : '||decRec.ENAME);
                DBMS_OUTPUT.PUT_LINE('JOB      : '||decRec.JOB);
                DBMS_OUTPUT.PUT_LINE('---------------------------');
                DBMS_OUTPUT.PUT_LINE('CUSTID   : '||decRec.CUSTID); DBMS_OUTPUT.PUT_LINE('CUSTNAME : '||decRec.NAME);
                DBMS_OUTPUT.PUT_LINE('CITY     : '||decRec.city);
                DBMS_OUTPUT.PUT_LINE('=====================================');
                FETCH MY_DEPT_EMP_CUST_CUR INTO decRec; -- fetch successive records
            END LOOP;
         DBMS_OUTPUT.PUT_LINE('CLOSING CURSOR..'); CLOSE MY_DEPT_EMP_CUST_CUR; -- close the active data set
         DBMS_OUTPUT.PUT_LINE('CURSOR CLOSED....');
        DBMS_OUTPUT.PUT_LINE('END');
       END;  	

-------------------------------------------------------------------

DECLARE
         CURSOR MY_DEPT_EMP_CUST_CUR IS SELECT dept.deptno,dname,loc, empno,ename,job,
                custid,name,city FROM DEPT,emp,customer where dept.deptno = emp.deptno 
                and emp.empno=customer.repid order by emp.empno; -- declare cursor

		-- no need of cursor type variable, for loop will take care of it

         BEGIN
         DBMS_OUTPUT.PUT_LINE('BEGIN'); DBMS_OUTPUT.PUT_LINE('OPENING CURSOR');

  	    -- no need to open the cursor

	    for decRec in MY_DEPT_EMP_CUST_CUR	 -- known as cursor for loop     
            LOOP
		-- no need to fetch the value, for loop will take care
                DBMS_OUTPUT.PUT_LINE('ROW      : '||MY_DEPT_EMP_CUST_CUR%ROWCOUNT);
                DBMS_OUTPUT.PUT_LINE('DEPTNO   : '||decRec.DEPTNO); DBMS_OUTPUT.PUT_LINE('DNAME    : '||decRec.DNAME);
                DBMS_OUTPUT.PUT_LINE('LOC      : '||decRec.LOC);
                DBMS_OUTPUT.PUT_LINE('---------------------------');
                DBMS_OUTPUT.PUT_LINE('EMPNO    : '||decRec.EMPNO); DBMS_OUTPUT.PUT_LINE('ENAME    : '||decRec.ENAME);
                DBMS_OUTPUT.PUT_LINE('JOB      : '||decRec.JOB);
                DBMS_OUTPUT.PUT_LINE('---------------------------');
                DBMS_OUTPUT.PUT_LINE('CUSTID   : '||decRec.CUSTID); DBMS_OUTPUT.PUT_LINE('CUSTNAME : '||decRec.NAME);
                DBMS_OUTPUT.PUT_LINE('CITY     : '||decRec.city);
                DBMS_OUTPUT.PUT_LINE('=====================================');
            END LOOP;

                DBMS_OUTPUT.PUT_LINE('===== Printing Again ===='); -- no need of open,fetch and close

	    for decRec in MY_DEPT_EMP_CUST_CUR	 -- known as cursor for loop     
            LOOP
		-- no need to fetch the value, for loop will take care
                DBMS_OUTPUT.PUT_LINE('ROW      : '||MY_DEPT_EMP_CUST_CUR%ROWCOUNT);
                DBMS_OUTPUT.PUT_LINE('DEPTNO   : '||decRec.DEPTNO); DBMS_OUTPUT.PUT_LINE('DNAME    : '||decRec.DNAME);
                DBMS_OUTPUT.PUT_LINE('LOC      : '||decRec.LOC);
                DBMS_OUTPUT.PUT_LINE('---------------------------');
                DBMS_OUTPUT.PUT_LINE('EMPNO    : '||decRec.EMPNO); DBMS_OUTPUT.PUT_LINE('ENAME    : '||decRec.ENAME);
                DBMS_OUTPUT.PUT_LINE('JOB      : '||decRec.JOB);
                DBMS_OUTPUT.PUT_LINE('---------------------------');
                DBMS_OUTPUT.PUT_LINE('CUSTID   : '||decRec.CUSTID); DBMS_OUTPUT.PUT_LINE('CUSTNAME : '||decRec.NAME);
                DBMS_OUTPUT.PUT_LINE('CITY     : '||decRec.city);
                DBMS_OUTPUT.PUT_LINE('=====================================');
            END LOOP;

        DBMS_OUTPUT.PUT_LINE('END'); -- no need to close the cursor, for loop will take care
       END;  

----------------------------------------------------------	


  Parameterized Cursor
  ------------------------


     DECLARE
         CURSOR MYEMPCUR(p_job varchar2, p_dno number) IS SELECT * FROM EMP WHERE 
						       JOB=p_job and DEPTNO=p_dno;
         EMPREC EMP%ROWTYPE; 

         v_job varchar2(20):='&EnterJob';  v_dno NUMBER:=&EnterDeptno; 
       BEGIN
         DBMS_OUTPUT.PUT_LINE('BEGIN');   DBMS_OUTPUT.PUT_LINE('OPENING CURSOR');

         OPEN MYEMPCUR(v_job,v_dno); -- SALESMAN, 30 IS PASSED DURING OPENING IT

         FETCH MYEMPCUR INTO EMPREC; -- fetch first record
            WHILE(MYEMPCUR%FOUND) -- test if it is found
            LOOP
                DBMS_OUTPUT.PUT_LINE('ROW    : '||MYEMPCUR%ROWCOUNT);
                DBMS_OUTPUT.PUT_LINE('EMPNO : '||EMPREC.EMPNO);
                DBMS_OUTPUT.PUT_LINE('ENAME : '||EMPREC.ENAME);
                DBMS_OUTPUT.PUT_LINE('JOB   : '||EMPREC.JOB);
                DBMS_OUTPUT.PUT_LINE('--------------------------');
                FETCH MYEMPCUR INTO EMPREC; -- fetch successive records
            END LOOP;
         DBMS_OUTPUT.PUT_LINE('CLOSING CURSOR..');
	 CLOSE MYEMPCUR; -- close the active data set
         DBMS_OUTPUT.PUT_LINE('CURSOR CLOSED....');
        DBMS_OUTPUT.PUT_LINE('END');
       END;
	
=========================================================================





	
	Exception handling

	----------------------

			handling run time errors



		declare

		begin


			exception 
				.......
				.......
				.......
		end;



		declare
			x number(3);
			y number(3);
			z number;
		begin
			DBMS_OUTPUT.PUT_LINE('Begin main');
			x:=&num1;
			DBMS_OUTPUT.PUT_LINE('x : '||x);

			y:=&num2;
			DBMS_OUTPUT.PUT_LINE('y : '||y);

			z:=x/y;
			DBMS_OUTPUT.PUT_LINE('z : '||z);

			DBMS_OUTPUT.PUT_LINE('end main');

			exception 
				when ZERO_DIVIDE then
					DBMS_OUTPUT.PUT_LINE('Cannot divide by zero');
				when value_ERROR then
					DBMS_OUTPUT.PUT_LINE('Please supply 3 digit number');
		end;




	----------------------------------------------------------

                declare
                     outer_x number:=100;
                begin
                                dbms_output.put_line('outer block ...begin');
                                dbms_output.put_line('outer_x : ' || outer_x);

                                declare
                                    inner_x number:=200;
				begin
                                     dbms_output.put_line('inner block...begin');
                                     dbms_output.put_line('outer_x : ' || outer_x);
                                     dbms_output.put_line('inner_x : ' || inner_x);
                                     dbms_output.put_line('inner block...end');
                                end;
                     dbms_output.put_line('outer block ...end');		
                end;


-----------------------------------------------

	begin
		declare
			x number(3):=&num1;  -- enter 1000 here 
			y number(3):=&num2;	z number;
		begin
			DBMS_OUTPUT.PUT_LINE('Begin main');

			DBMS_OUTPUT.PUT_LINE('x : '||x);
			DBMS_OUTPUT.PUT_LINE('y : '||y);

			z:=x/y;
			DBMS_OUTPUT.PUT_LINE('z : '||z);

			DBMS_OUTPUT.PUT_LINE('end main');

			exception 
				when ZERO_DIVIDE then
					DBMS_OUTPUT.PUT_LINE('Cannot divide by zero');
				when value_ERROR then
					DBMS_OUTPUT.PUT_LINE('Please supply 3 digit number');
		end;

		exception -- outer block excpetion here
			when value_ERROR then
				DBMS_OUTPUT.PUT_LINE('OuterBLock : Please supply 3 digit number');
	end; -- outer block


-----------------------------------------------------------------------------


	User defined exception 

delete from dept where deptno=10;

	ORA-02292: integrity constraint (SYSTEM.EMP_FOREIGN_KEY) violated - 
	child record found  ( means there are employees in emp (child) table for deptno=10) 

insert into emp values (1111,'Jack','CLERK',7839,'12-Dec-20',4000,300,15)

	ORA-02291: integrity constraint (SYSTEM.EMP_FOREIGN_KEY) violated - 
	parent key not found - means there is no such deptno as 15 in dept(parent) table


	2292  - child record found - "Employee exists...can not delete!!!"

	2291  - parent key not found - "Department Not found - cannot insert!!!"

	what if we try to change the salary of the 
	employees more than their manager's salary??? it should throw exception




	declare
		new_sal number;		boss_salary number;
		worker_eno number;	worker_sal number;

		check_sal EXCEPTION; -- making a variable of the type Exception
	begin
		worker_eno:=&EnterEmpNumber;
		new_sal:=&EnterNewSalary;

		select boss.sal, worker.sal INTO boss_salary,worker_sal 
		from emp boss, emp worker 
		where boss.empno = worker.mgr and worker.empno = worker_eno;

		if(new_sal > boss_salary) then
			raise check_sal;  -- raise(throw) the exception
		else
			update emp set sal=new_sal where empno=worker_eno;
			dbms_output.put_line('Worker''s salary updated as : '||new_sal);
		end if;

		exception 
			when check_sal then
				dbms_output.put_line('Worker''s salary cannot be more than their 
				manager''s salary');
			when others then -- master handler for any other exception
				dbms_output.put_line('some problem');
	end;






below example is associating -2292 ( child record found ) with user defined exception, i.e.,
								emp_found_exception  

	declare
	     emp_found_exception  EXCEPTION;
	     pragma exception_init(emp_found_exception, -2292); -- this error is associated now
        begin
             dbms_output.put_line('Trying to delete department number');
             delete from dept where deptno=&EnterDeptNumber; -- it will raise emp_found_exception
	     if(sql%found) then
	             dbms_output.put_line('Deleted department number');
	     else
		     dbms_output.put_line('Record NOT found : ');
	     end if;
	     exception 
		when  emp_found_exception then
                dbms_output.put_line('Cannot delete, employee found in emp table');
        end;


------------------------------------------------------------------------

  Procedure  and  Functions

			- stored procedure and stored functions


  create or replace procedure greet
  as
       hour_of_day number;
    begin
       select to_char(sysdate,'HH24') into hour_of_day from dual;
       if(hour_of_day<12) then
          dbms_output.put_line('Good Morning');
       else
          if(hour_of_day>12 and hour_of_day<16) then
           dbms_output.put_line('Good Afternoon');
         else
            if(hour_of_day>=16 and hour_of_day<21) then
               dbms_output.put_line('Good Evening');
            else
               if(hour_of_day>=21) then
                  dbms_output.put_line('Good Night');
               else
                  dbms_output.put_line('Have a good time');
               end if;
           end if;
        end if;
     end if;
   end;
   /
  
SQL> execute greet;
SQL> select text from user_source where name='GREET'; // GREET must be in capital case

	create or replace procedure change_salary(worker_eno number, new_sal number)
	as
		boss_salary number;
		worker_sal number;
		check_sal EXCEPTION; -- making a variable of the type Exception
	begin
		select boss.sal, worker.sal INTO boss_salary,worker_sal 
		from emp boss, emp worker 
		where boss.empno = worker.mgr and worker.empno = worker_eno;

		if(new_sal > boss_salary) then
			raise check_sal;  -- raise(throw) the exception
		else
			update emp set sal=new_sal where empno=worker_eno;
			dbms_output.put_line('Worker''s salary updated as : '||new_sal);
		end if;

		exception 
			when check_sal then
				dbms_output.put_line('Worker''s salary cannot be more than their 
				manager''s salary');
			when others then -- master handler for any other exception
				dbms_output.put_line('some problem');
	end;

	SQL> execute change_salary(7782,4500);
	SQL> select sal from emp where empno=7782;

-------------------------------------------------------------

  declare
       eno number;
       newsal number;
    begin
        eno:=&EnterEmpNumber;
        newsal:=&EnterNewSal;

        change_salary(eno,newsal); -- stored block is called here
   end;


-------------------------------------------------------------
  PROCEDURE WITH IN AND OUT PARAMETERS


  CREATE OR REPLACE PROCEDURE EMP_INFO(ENO IN NUMBER, V_ENAME OUT VARCHAR2, V_JOB OUT VARCHAR2)
  AS
  BEGIN
     SELECT ENAME,JOB INTO V_ENAME,V_JOB FROM EMP WHERE EMPNO=ENO;
     
     EXCEPTION WHEN NO_DATA_FOUND THEN
	V_ENAME:=NULL;
        V_JOB:=NULL;
  END;  
----------------------------------------------------------------
  DECLARE
       E NUMBER;
       X VARCHAR2(20);
       Y VARCHAR2(20);
    BEGIN
       E:=&EnterEmpNumber;
       emp_info(E,X,Y);  -- INVOKE PROCEDURE HERE AND PASS 1 IN AND 2 OUT PARAMETERS
       dbms_output.put_line('EMP NAME : '||X);
       dbms_output.put_line('EMP JOB  : '||Y);
   END;
   /




	it is not compulsory to return value from a procedure

	it is     compulsory to return value from a function


						mandatory to be written
						   |
 create or replace function calc_sal(eno number) return number
    as
       total_sal number;
    begin
       select sal+nvl(comm,0) into total_sal from emp where empno=eno;
       return total_sal; -- return is mandatory, since its a function
       exception when no_data_found then
         return 0;
    end;
   /





	select greet from dual ;   we cannot call procedure from a select query

	select calc_sal(7839) from dual;  we can call it from a select query


	dbms_output.put_line('hello);
	   |          |
	package    function


		

	myemp.calc_sal(empno) // <-- this is the invocation line
	myemp.calc_bonus(empno)
	myemp.upraise_sal(empno,newsal)


	mycustomer.findOrder(custid)
	mycustomer.findProductsOrdered(custid)



		create or replace package myemp
		is
			function  calc_sal(eno number) return number;
			function  calc_bonus(eno number) return number;
			procedure upraise_sal(eno number ,newsal number);
		end;
		
  create or replace package body myemp
  is
    -- below function is a private function of this package body - it can be used inside package body
    function findEmp(eno number) return number -- this function is not declared inside package
    as
      v_ename varchar2(20);
    begin
      select ename into v_ename from emp where empno=eno;
      return 1;

     exception when no_data_found then
            return 0;
   end;
    
    function calc_sal(eno number) return number
    as
      total_sal number;
    begin
      select sal+nvl(comm,0) into total_sal from emp where empno=eno;
      return total_sal; -- return is mandatory, since its a function
      exception when no_data_found then
      return 0;
    end; -- end of the function

    function calc_bonus(eno number) return number
     as
      total_bonus number;
      x number;
    begin
      x:=findEmp(eno); -- internally called by the package body here
      dbms_output.put_line('Employee found : '||x);
      select sal+sal*0.20 into total_bonus from emp where empno=eno;
      return total_bonus; -- return is mandatory, since its a function
      exception when no_data_found then
      return 0;
    end; -- end of the function

    procedure upraise_sal(eno number ,newsal number)
    as
      boss_salary number;
      worker_sal number;
      check_sal EXCEPTION; -- making a variable of the type Exception
    begin
         select boss.sal, worker.sal INTO boss_salary,worker_sal 
         from emp boss, emp worker 
         where boss.empno = worker.mgr and worker.empno = eno;

         if(newsal > boss_salary) then
            raise check_sal;  -- raise(throw) the exception
         else
             update emp set sal=newsal where empno=eno;
             dbms_output.put_line('Worker''s salary updated as : '||newsal);
         end if;
         exception 
             when check_sal then
               dbms_output.put_line('Worker''s salary cannot be more than their manager''s salary');
            when others then -- master handler for any other exception
               dbms_output.put_line('some problem');
    end; -- end of the procedure

   

 end;  -- end of the package body





  create or replace function findEmp(eno number) return number
    as
      v_ename varchar2(20);
    begin
      select ename into v_ename from emp where empno=eno;
      return 1;

     exception when no_data_found then
            return 0;
   end;




